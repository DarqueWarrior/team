name: $(Build.BuildID)

trigger:
- master

resources:
- repo: self

variables:
  # Agent VM image name
  vmLinuxImageName: 'ubuntu-latest'
  vmmacOSImageName: 'macOS-latest'
  vmWindowsImageName: 'windows-latest'
  Folder: 'dist'

stages:
- stage: Build
  displayName: Build Stage

  jobs:
  - job: macOS_Linux_Phase
    displayName: 'Build'
    strategy:
      matrix:
        macOS:
          OS: 'macOS'
          vmImageName: 'macOS-latest'
        Linux:
          OS: 'Linux'
          vmImageName: 'ubuntu-latest'
      maxParallel: 2
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NuGetToolInstaller@0
      displayName: 'Use NuGet 5.2.0'
      inputs:
        versionSpec: '5.2.0'

    - task: PowerShell@2
      displayName: 'Register Private Repository'
      inputs:
        targetType: 'inline'
        script: |
          $n = 'LoECDA'
          $e = "$(EMAIL)"
          $url = "$(REPO_URL)"
          $pwd = ConvertTo-SecureString $env:PKG_PAT -AsPlainText -Force
          $creds = New-Object PSCredential($e, $pwd)

          if(-not (Get-PSRepository | ? Name -eq $n)) {
              Register-PSRepository -Credential $creds -Name $n -SourceLocation $url -InstallationPolicy Trusted -Verbose
          }
          
    - task: PowerShell@2
      displayName: 'Build Module'
      inputs:
        targetType: 'inline'
        script: '.\Build-Module.ps1 -installDep'

    - task: PowerShell@2
      displayName: 'Install Pester'
      inputs:
        targetType: 'inline'
        script: 'Install-Module -Name Pester -Repository PSGallery -Force -Scope CurrentUser -AllowClobber -SkipPublisherCheck'

    - task: PowerShell@2
      displayName: 'Run Unit Tests'
      inputs:
        targetType: 'inline'
        script: |
          Import-Module .\dist\*.psd1
          Invoke-Pester -Script .\unit -EnableExit -Strict -OutputFile test-results.xml -OutputFormat NUnitXml -passthru
        workingDirectory: '$(System.DefaultWorkingDirectory)'

    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'NUnit'
        testResultsFiles: '**\test-results.xml'
        testRunTitle: '$(OS) Unit Tests'
      condition: succeededOrFailed()

  - job: Windows_Phase
    displayName: Build Windows
    pool:
      vmImage: $(vmWindowsImageName)

    steps:
    - task: PowerShell@2
      displayName: 'Build Module'
      inputs:
        targetType: 'inline'
        script: '.\Build-Module.ps1 -installDep -buildHelp'

    - task: PowerShell@2
      displayName: 'Install PSScriptAnalyzer'
      inputs:
        targetType: 'inline'
        script: 'Install-Module -Name PSScriptAnalyzer -Repository PSGallery -Force -Scope CurrentUser -Verbose'

    - task: PowerShell@2
      displayName: 'Run Static Code Analysis'
      inputs:
        targetType: 'inline'
        script: |
          # Has to happen in this task for it to take effect
          # Load the psd1 file so you can read the required modules and import them
          $manifest = Import-PowerShellDataFile .\dist\*.psd1

          # Import each module
          $manifest.RequiredModules | ForEach-Object { Import-Module -Name $_ }

          $r = Invoke-ScriptAnalyzer –Path ./dist –Recurse | Where-Object severity -ne "Information"
          $r | ForEach-Object {Write-Host "##vso[task.logissue type=$($_.Severity);sourcepath=$($_.ScriptPath);linenumber=$($_.Line);columnnumber=$($_.Column);]$($_.Message)"}

    # - task: PowerShell@2
    #   displayName: 'Install Pester'
    #   inputs:
    #     targetType: 'inline'
    #     script: 'Install-Module -Name Pester -Repository PSGallery -Force -Scope CurrentUser -AllowClobber -SkipPublisherCheck -Verbose'

    # - task: PowerShell@2 |
    #     Import-Module .\dist\*.psd1
    #     Invoke-Pester -Script .\unit -CodeCoverage .\dist\*.ps*1 -CodeCoverageOutputFile coverage.xml -CodeCoverageOutputFileFormat JaCoCo -EnableExit -Strict -OutputFile test-results.xml -OutputFormat NUnitXml

    #   workingDirectory: '$(System.DefaultWorkingDirectory)'
    #   condition: and(succeededOrFailed(), eq(variables['System.PullRequest.IsFork'], false))
    #   displayName: 'Run Unit Tests with Code Coverage'

    # - task: PowerShell@2 |
    #     Import-Module .\dist\*.psd1
    #     Invoke-Pester -Script .\unit -EnableExit -Strict -OutputFile test-results.xml -OutputFormat NUnitXml -passthru
    #   workingDirectory: '$(System.DefaultWorkingDirectory)'
    #   condition: and(succeededOrFailed(), eq(variables['System.PullRequest.IsFork'], true))
    #   displayName: 'Run Unit Tests'

    # - task: PublishTestResults@2
    #   displayName: 'Publish Test Results'
    #   inputs:
    #     testRunner: NUnit
    #     testResultsFiles: '**\TEST-*.xml'
    #     testRunTitle: 'Windows Unit Tests'
    #   condition: succeededOrFailed()

    # - task: PublishCodeCoverageResults@1
    #   displayName: 'Publish code coverage'
    #   inputs:
    #     summaryFileLocation: '**\coverage.xml'
    #     failIfCoverageEmpty: true
    #  condition: and(succeededOrFailed(), eq(variables['System.PullRequest.IsFork'], false))

    - task: CredScan@2
      displayName: 'Run CredScan'
      inputs:
        suppressionsFile: '$(Build.SourcesDirectory)/build/credscan-supression.json'

    - task: SdtReport@1
      displayName: 'Create Security Analysis Report'
      inputs:
        AllTools: true

    - task: PublishSecurityAnalysisLogs@2
      displayName: 'Publish Security Analysis Logs'

    - task: PostAnalysis@1
      displayName: 'Post Analysis'
      inputs:
        AllTools: true

    - task: CopyFiles@2
      displayName: 'Copy Module to Artifacts Folder'
      inputs:
        Contents: |
          README.md
          .gitignore
          dist\**
        TargetFolder: '$(build.artifactstagingdirectory)/VSTeam'
        flattenFolders: false
      condition: and(succeeded(), eq(variables['System.PullRequest.IsFork'], false))

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Module'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/VSTeam'
        artifact: 'module'
      condition: and(succeeded(), eq(variables['System.PullRequest.IsFork'], false))

    - task: CopyFiles@2
      displayName: 'Copy Integration Tests Artifacts Folder'
      inputs:
        Contents: |
          dist\*.psd1
          integration\**
        TargetFolder: '$(build.artifactstagingdirectory)/Tests'
      condition: and(succeeded(), eq(variables['System.PullRequest.IsFork'], false))

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Tests'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/Tests'
        artifact: 'test'
      condition: and(succeeded(), eq(variables['System.PullRequest.IsFork'], false))

- stage: Package
  displayName: Package Management
  dependsOn: Build
  jobs:
  - deployment: Deploy
    displayName: Package Management
    pool:
      vmImage: $(vmWindowsImageName)
    environment: 'Package Management'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            displayName: 'Update Modules'
            inputs:
              targetType: 'inline'
              script: |
                Update-Module PackageManagement -Verbose -Force -Scope CurrentUser
                Update-Module PowerShellGet -Verbose -Force -Scope CurrentUser

          - task: NuGetToolInstaller@0
            displayName: 'Use NuGet 5.2.0'
            inputs:
              versionSpec: '5.2.0'

          - pwsh: Get-Module -ListAvailable PackageManagement, PowerShellGet
          
          - task: PowerShell@2
            displayName: 'Register Private Repository'
            inputs:
              targetType: 'inline'
              script: |
                $n = 'LoECDA'
                $e = "$(EMAIL)"
                $url = "$(REPO_URL)"
                $pwd = ConvertTo-SecureString "afrofqbrxqbs3zonjdganx4bhuwypeml3dj7etsbrcuazw6mw5rq" -AsPlainText -force
                $creds = New-Object PSCredential($e, $pwd)
                if(-not (Get-PSRepository | ? Name -eq $n)) {
                    Register-PSRepository -Credential $creds -Name $n -SourceLocation $url -InstallationPolicy Trusted -Verbose
                }

          - task: PowerShell@2
            displayName: 'Install Module Dependencies'
            inputs:
              targetType: 'inline'
              script: |
                # Load the psd1 file so you can read the required modules and install them
                $manifest = Import-PowerShellDataFile .\$(Folder)\*.psd1

                # Install each module
                $manifest.RequiredModules | ForEach-Object { Install-Module -Name $_ -Repository PSGallery -F -Scope CurrentUser }
              workingDirectory: '$(Pipeline.Workspace)/module'

          - task: PowerShell@2
            displayName: 'Compute Version Number'
            inputs:
              targetType: 'inline'
              script: |
                # Load the psd1 file so you can read the version
                $manifest = Import-PowerShellDataFile .\$(Folder)\*.psd1

                Write-Host "##vso[task.setvariable variable=PACKAGE_VERSION;isOutput=false]$($manifest.ModuleVersion).$(Build.BuildId)"
              workingDirectory: '$(Pipeline.Workspace)/module'

          - task: PowerShell@2
            displayName: 'Create NuSpec from PSD1'
            inputs:
              targetType: 'inline'
              script: |
                Install-Module -Name Trackyon.Nuget -Scope CurrentUser -Force -Verbose
                ConvertTo-NuSpec -Path ./$(Folder)/VSTeam.psd1
              workingDirectory: '$(Pipeline.Workspace)/module'

          - task: NuGetCommand@2
            displayName: 'Pack Module'
            inputs:
              command: pack
              packagesToPack: '$(Pipeline.Workspace)/module/$(Folder)/VSTeam.nuspec'
              packDestination: '$(Pipeline.Workspace)/module/$(Folder)'
              versioningScheme: byEnvVar
              versionEnvVar: 'PACKAGE_VERSION'

          - task: NuGetCommand@2
            displayName: 'Push Module'
            inputs:
              command: push
              packagesToPush: '$(Pipeline.Workspace)/module/$(Folder)/*.nupkg'
              publishVstsFeed: 'vsteam'
              allowPackageConflicts: true

- stage: Testing
  displayName: Testing stage
  dependsOn: Package
  jobs:
  - deployment: LinuxTFS2017
    displayName: Linux TFS 2017
    pool:
      vmImage: $(vmLinuxImageName)
    environment: 'Linux TFS 2017'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: NuGetToolInstaller@0
              displayName: 'Use NuGet 5.2.0'
              inputs:
                versionSpec: '5.2.0'
            - task: PowerShell@2
              displayName: 'Register Private Repository'
              inputs:
                targetType: 'inline'
                script: |
                  $n = 'LoECDA'
                  $e = "$(EMAIL)"
                  $url = "$(REPO_URL)"
                  $pwd = ConvertTo-SecureString $env:PKG_PAT -AsPlainText -Force
                  $creds = New-Object PSCredential($e, $pwd)

                  if(-not (Get-PSRepository | ? Name -eq $n)) {
                      Register-PSRepository -Credential $creds -Name $n -SourceLocation $url -InstallationPolicy Trusted -Verbose
                  }

            - task: PowerShell@2
              displayName: 'Install VSTeam Module'
              inputs:
                targetType: 'inline'
                script: |
                  # Load the psd1 file so you can read the version
                  $manifest = Import-PowerShellDataFile .\$(Folder)\*.psd1

                  $n = 'LoECDA'
                  $e = "$(EMAIL)"
                  $b = "$($manifest.ModuleVersion).$(Build.BuildId)"
                  $pwd = ConvertTo-SecureString $env:PKG_PAT -AsPlainText -Force
                  $creds = New-Object PSCredential($e, $pwd)

                  Install-Module -Name VSTeam -Repository $n -Credential $creds -MaximumVersion $b -MinimumVersion $b -Scope CurrentUser -Verbose
                workingDirectory: '$(Pipeline.Workspace)/test'

            - task: PowerShell@2
              displayName: 'Install Pester'
              inputs:
                targetType: 'inline'
                script: 'Install-Module -Name Pester -MinimumVersion 4.3.1 -MaximumVersion 4.3.1 -Repository PSGallery -Force -Scope CurrentUser -AllowClobber -SkipPublisherCheck'

            - task: PowerShell@2
              displayName: 'Run Integration Tests'
              inputs:
                targetType: 'inline'
                script: |
                  $env:PAT='$(2017PAT)'
                  Import-Module VSTeam
                  Invoke-Pester -EnableExit -Strict -OutputFile test-results.xml -OutputFormat NUnitXml
                failOnStderr: true
                workingDirectory: '$(Pipeline.Workspace)/test/integration'

            - task: PublishTestResults@2
              displayName: 'Publish Test Results'
              inputs:
                testResultsFormat: NUnit
                testResultsFiles: '**/test-results.xml'
                searchFolder: '$(Pipeline.Workspace)/test/integration'
                testRunTitle: 'Linux Tests'
              continueOnError: true
              condition: succeededOrFailed()

  - job: macOSTFS2017
    displayName: macOS TFS 2017
    dependsOn: LinuxTFS2017
    pool:
      vmImage: $(vmmacOSImageName)
    steps:
    - script: echo macOS TFS 2017
  - job: WindowsTFS2017
    displayName: Windows TFS 2017
    dependsOn: macOSTFS2017
    pool:
      vmImage: $(vmWindowsImageName)
    steps:
    - script: echo Windows TFS 2017
  - job: TFS2018
    displayName: TFS 2018 Integration Tests
    pool:
      vmImage: $(vmWindowsImageName)
    steps:
    - script: echo TFS 2018 Integration Tests
  - job: AzD
    displayName: AzD Integration Tests
    pool:
      vmImage: $(vmWindowsImageName)
    steps:
    - script: echo AzD Integration Tests

- stage: Produciton
  displayName: PowerShell Gallery
  dependsOn: Testing
  jobs:
  - deployment: Deploy
    displayName: PowerShell Gallery
    pool:
      vmImage: $(vmWindowsImageName)
    environment: 'PowerShell Gallery'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: echo PowerShell Gallery